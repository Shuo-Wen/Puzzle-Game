# Puzzle-Game
This is the final project of "Basic Java Programming" fall 2018 in KU Leuven. 
Here are the guidelines of the project:  For this project, you will code a single player electronic board game in Java. 
The player can explore the board in order to reach an ultimate goal. Our version of this game, Dancing With the Stars, serves as an example of one possible implementation. In our Dancing game, the player is a contestant on the show. There are different difficulty levels which affect many aspects of the game. The player chooses settings for the game, including the difficulty level and the distribution of the player’s skills (balance between good looks and dancing skills), at the beginning. He or she aims to win the trophy. Before doing so, a number of jurors and stars must be impressed, either by dancing well or looking good. In order to improve dancing skills and looks, the player can compete in dance offs against competitors. The location of the trophy, competitors, stars, and judges is hidden from the player’s view, except for a small radius around his or her current location which is visible. There are some obstacles around the board, such as blinding stage lights which diminish a player’s looks and slippery dance floor which inhibit a player’s ability to dance. Moving around the board and interacting with other characters costs energy. The player must win the trophy before running out of energy or the game is lost. Screenshots from the game and a short video on Toledo will give you a better idea of how the Dancing game plays. The setting of your game is entirely up to you; there is no reason you should copy the Dancing theme. The possibilities are endless, e.g. a war or battle, capturing a castle, picking fruit to bake a pie, running a farm, etc. While we would like you to express your creativity when it comes to the back story, we do expect you to include several specific components which are designed to make use of the concepts you’ve learned in this course. Minimal Requirements (you may go above and beyond!): •	A grid of tiles which can contain one of several things: o	Terrain (e.g. blinding spot lights, slippery dance floor): terrain tiles may influence your player positively or negatively (e.g. when challenging a Juror near a slippery dance floor, the player’s dance skills are temporarily decreased) o	Opponents (e.g. jurors and stars): overcoming opponents should be evaluated based on your player’s skills and should include some random element (e.g. a Juror has a random threshold which a player’s dancing skills should be above, in order to impress that Juror) o	Prize (e.g. trophy): there should be some minimum requirements the player must meet before they can claim the prize o	The tiles should be randomly assigned for each new game. •	Difficulty Levels: o	You should offer different difficulty levels for the user to choose. The levels should make the game harder or easier, but how they actually impact it is up to you, (e.g. higher difficulty level results in a larger game board and less energy) •	Visibility: o	Only a specific radius of tiles around the Player is visible at any time •	Your Player: o	Players should have skill attributes (which can be chosen by the user and also impacted by game play, e.g. winning a dance off allows the player to gain looks or dancing skills) o	Players have energy (or some similar measure); the game is lost when this runs out o Players can move from tile to tile, which costs some energy • High Scores: o	You should keep track of high scores even when the game is closed, so that next time you play, your score is compared against the existing high scores. Key Points: The structure of your code is the most important evaluation for the project. This means you should take care to include as many of the object oriented concepts covered in the course as you can. However, use them in intelligent ways, just forcing something for the sake of including it does not add value to your project. A nice GUI and a creative setting will count towards your final grade, but is not required to pass. On the other hand, an exceptional GUI without well-developed underlying logic is not sufficient. A text-based console input and output is acceptable if you are unable to complete a graphical interface. 
So to summarize: a well-designed text based project can be better than a bad GUI since we want you to focus first on the logic!

#The rule of my game:
The goal: Controlling the hero walk in the cave (table/grid) to fight with monsters(with attribute black/white) and collect required amount of treasures (Ruby+Sapphire+Emerald) before finally find the exit. 
In each round, the player can choose different level (A to F) and attribute of himself (black and white).  
  Note that the attributes can affect the probability that the character win the monsters.

  At the begining, the player has 100 HP. 
  By ssing the keyboard (w/s/a/d), the player can control the hero move in the cave (up, down, right, left). 
  Only the nearby blocks of the hero is visible. 
  Each move will consume 2 HP of the hero. 
  If the character step into the block where a monster stays, the character have to duel with it. 
  The chance of wining is random, but it was actually affected by the level you chose and attributes of monsters and hero.
  If the player wins, the monster will be eliminated and drop different types of treasure, which is beneficial to hero. 
  If the player loses, the hero will lose 5 HP and the monster will stay at that block and the very next step you can only run away. 
  After the player collect enough number of treasures (defalt setting Ruby*2+Sapphire*2+Emerald*2), he or she can either choose the exit or wining the game, which is hidden in the gird. 
  The default setting of the fight is: If a hero duel with one monster having the same attribute as him or her, the chance to win will be 2/3; otherwise it would be 1/2)
